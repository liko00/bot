Yes, you can create a state for each day of the week to allow users to select a different time for each day. However, creating 7 different states for each day of the week can be cumbersome and not scalable if you want to add more features or options in the future.

Instead, you can use a dictionary to store the selected time for each day of the week. Here is an example of how you can modify your Form class to include a dictionary for storing the selected times:

pythonCopy code
class Form(StatesGroup):
    username = State()
    name = State()
    visits = State()
    count = State()
    days = State()
    num_days = State()
    times = State()
    info_username = State()
    delete_username = State()
    
    def __init__(self):
        self.times_selected = {}


In the __init__ method of the Form class, we initialize an empty dictionary called times_selected that we will use to store the selected times for each day of the week.

Then, in the process_days state, you can modify the logic to allow users to select a time for each day of the week:

pythonCopy code
@dp.message_handler(state=Form.days)
async def process_days(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        days = data.get("days", [])
        selected_day = message.text
        if selected_day in days:
            await message.reply(f"{selected_day} has already been selected. Please choose a different day.")
            return
        days.append(selected_day)
        data["days"] = days
        num_days = data.get("num_days", 0)
        if len(days) >= num_days:
            # Store the selected days in the state
            await state.update_data(days=days)
            await Form.times.set()
            # Ask the user to select a time for each day of the week
            await message.reply("Please select the time for each day of the week:")
        else:
            await message.reply(f"Please select {num_days - len(days)} more day(s) of the week:", reply_markup=days_keyboard)


Here, we update the state to Form.times and ask the user to select a time for each day of the week.

Finally, in the process_times state, you can modify the logic to store the selected time for each day of the week in the times_selected dictionary:

pythonCopy code
@dp.message_handler(state=Form.times)
async def process_times(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        times_selected = state.times_selected
        days = data["days"]
        selected_time = message.text
        times_selected[selected_day] = selected_time
        if len(times_selected) == len(days):
            # Store the selected times in the state
            await state.update_data(times=times_selected)
            # Display the summary to the user
            summary = "\n".join([f"{day}: {times_selected[day]}" for day in days])
            await message.reply(f"You have selected the following times:\n{summary}")
            # Move to the next state or finish the conversation
        else:
            # Ask the user to select the time for the next day
            next_day = [day for day in days if day not in times_selected][0]
            await message.reply(f"Please select the time for {next_day}:")


Here, we store the selected time in the times_selected dictionary for the selected day. Then, if all days have a selected time, we update the state to include the selected times and display a summary to the user

Regenerate response
